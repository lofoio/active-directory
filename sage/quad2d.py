# -*- coding:utf-8 -*-
# This file was *autogenerated* from the file ./quad2d.sage.
from sage.all_cmdline import *   # import sage library
_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_4 = Integer(4); _sage_const_0p25 = RealNumber('0.25'); _sage_const_0p5 = RealNumber('0.5'); _sage_const_0p0 = RealNumber('0.0'); _sage_const_3p = RealNumber('3.')#!/usr/bin/env sage

from sage.all import *

# 用节点插值单元。
def Quad2D4Node_Stiffness(E,NU,thick,ID,ic,celdes,xyz):
    """弹性模量 E,泊松比 NU,厚度 h
     4 个节点 i、j、m、p 的坐标 xi,yi,xj,yj,xm,ym,xp,yp
    平面问题性质指示参数 ID(1 为平面应力,2 为平面应变)
    单元刚度矩阵 k(8X8)"""
    i,j,k,l = celdes[ic]
    xi,yi = xyz[i]
    xj,yj = xyz[j]
    xk,yk = xyz[k]
    xp,yp = xyz[l]
    ks = [_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ,_sage_const_1 ]
    yt = [_sage_const_1 ,_sage_const_1 ,-_sage_const_1 ,-_sage_const_1 ]
    a = _sage_const_0p5 *abs(xi-xj)
    b = _sage_const_0p5 *abs(yj-yk)
    noe = len(celdes[ic])
    ents = []
    for r in range(noe):
        for s in range(noe):
            krs = ks[r]*ks[s]
            yrs = yt[r]*yt[s]
            k1 = b*b*krs*(_sage_const_1 +yrs/_sage_const_3p )+(_sage_const_1 -NU)*_sage_const_0p5 *a*a*yrs*(_sage_const_1 +krs/_sage_const_3p )
            k2 = a*b*(NU*yt[r]*ks[s]+(_sage_const_1 -NU)*_sage_const_0p5 *ks[r]*yt[s])
            k3 = a*b*(NU*yt[s]*ks[r]+(_sage_const_1 -NU)*_sage_const_0p5 *ks[s]*yt[r])
            k4 = a*a*yrs*(_sage_const_1 +krs/_sage_const_3p )+(_sage_const_1 -NU)*_sage_const_0p5 *b*b*krs*(_sage_const_1 +yrs/_sage_const_3p )
            ents.append(matrix(RR,_sage_const_2 ,_sage_const_2 ,[k1,k3,k2,k4])*E*thick*_sage_const_0p25 /((_sage_const_1 -NU*NU)*a*b))
    return block_matrix(_sage_const_4 ,_sage_const_4 ,ents)

def Assembly(dof,KK,k,ns):
    noe = len(ns)
    for a in range(noe):
        for b in range(noe):
            l  = a*dof
            ll = ns[a]*dof
            r  = b*dof
            rr = ns[b]*dof
            for i in range(dof):
                for j in range(dof):
                    KK[ll+i,rr+j] += k[l+i,r+j]

def bcsolver(dof,bcsf):
    ns = []
    ps = []
    for t in bcsf:
        tt = (len(t)-_sage_const_1 )/_sage_const_2 
        for i in range(tt):
            if t[i*dof+_sage_const_1 ] == "x":
                n = int(t[_sage_const_0 ])*dof
                p = t[i*dof+_sage_const_2 ]
            elif t[i*dof+_sage_const_1 ] == "y":
                n = int(t[_sage_const_0 ])*dof+_sage_const_1 
                p = t[i*dof+_sage_const_2 ]
            ns.append(n)
            ps.append(float(p))
    return ns, ps

with open("quad.txt", 'r') as infile:
    cells,nodes,bcs = [int(x) for x in infile.readline().split()]
    celdes = []
    xyz    = []
    bcsf   = []
    for i in range(cells):
        celdes += [[int(x)-_sage_const_1  for x in infile.readline().split()]]
    for i in range(nodes):
        xyz += [[float(x) for x in infile.readline().split()]]
    for i in range(bcs):
        bcsf += [infile.readline().split()]
    dof = int(infile.readline().split()[_sage_const_1 ])
    thick = float(infile.readline().split()[_sage_const_1 ])
    E = float(infile.readline().split()[_sage_const_1 ])
    NU = float(infile.readline().split()[_sage_const_1 ])

KK = matrix(RR,dof*nodes,dof*nodes)

for i in range(cells):
    k = Quad2D4Node_Stiffness(E,NU,thick,_sage_const_1 ,i,celdes,xyz)
    Assembly(dof,KK,k,celdes[i])

sub_k,sub_p = bcsolver(dof,bcsf)
KKs = KK.matrix_from_rows_and_columns(sub_k,sub_k)
sub_u = vector(sub_p)/KKs
U = [_sage_const_0p0 ]*nodes*dof
for i in range(len(sub_k)):
    U[sub_k[i]]=sub_u[i]
P = KK*vector(U)
# ## no need to transpose vectors
energy = _sage_const_0p5 *vector(U)*KK*vector(U)
work = vector(U)*P
poten = energy - work
print poten
